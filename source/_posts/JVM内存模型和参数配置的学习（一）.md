---
title: 'JVM内存模型和参数配置的学习（一）'
date: 2020-08-20 15:06:01
tags: 
- Java
- 虚拟机
- JVM
category: Java小技巧
---

众所周知，JVM内部主要空间可以分成2大部分
1. JVM虚拟机数据区
1. 本地内存

JVM虚拟机数据区包含了堆，本地方法栈，虚拟机栈和程序计数区。
本地内存包含了元数据区和直接内存。
这其中堆内存和本地内存是所有线程共享的，栈内存和程序计数器是线程私有的。

<img src="/blog.io/img/JVM内存模型.png">

#### 堆内存（heap）
堆内存在虚拟机启动的时候被创建，这个内存区域***唯一的作用是存放对象的实例***。堆内存主要分成两个部分：
- 年轻代
- 老年代
- metaspace

年轻代又由Eden， from和to组成。（8：1：1）
Young和Old的比例大约造1：2左右。这个值可以通过参数 –XX:NewRatio 来指定
 JDK8使用metaspace来替代了permsize:永久代大小

#### 元数据区

元数据区也就是原来的方法区也被叫做“永久代”，也是我们经常理解的“静态区”。这个地方储存的是
1. 类的元信息
1. 常量（1.7后从永久代移到堆）
1. 静态变量（1.7后从永久代移到堆）

由此可得，这些是所有线程都需要的，所以是公共区域。类的元数据信息不再像永久代一样存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中，这样还增加了堆的空间。新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。（GC时如果超的很多就增加，如果相反就减少这个值）

#### 栈内存（Stack)

栈内存分为两个部分：
1. 虚拟机栈（JVM Stack）
	每个方法被**执行**的时候都会创建一个"**栈帧**",用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
1. 本地方法栈（native Stack）
	本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。
	
#### 直接内存（堆外内存）
堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

Java8中我们经常用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。

优点：
1. 减少了垃圾回收
因为垃圾回收会暂停其他的工作。

1. 加快了复制的速度
堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。

缺点：
1. 同样任何一个事物使用起来有优点就会有缺点，堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。

堆外内存的OOM：
1. java.nio.DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，每个DirectByteBuffer对象在初始化时，都会创建一个对应的Cleaner对象。这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存。
2. 这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，当下一次FGC执行时，Cleaner对象会将自身Cleaner链表上删除，并触发clean方法清理堆外内存。但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了
3. 因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。
1. 其实，在ByteBuffer.allocateDirect方式中，会主动调用System.gc()强制执行FGC。


堆内和堆外内存相关链接：
1. https://blog.csdn.net/ZYC88888/article/details/80228531
（including gc）

1. https://www.cnblogs.com/reload-sun/p/12216931.html
（including gc）
   
1. https://blog.51cto.com/15065850/2603114
（gc）


#### 程序计数器
这个是在多线程的时候，如果执行的程序突然失去了资源，等会回来的时候根据这个计数器就可以找到上一次执行到的地方，Native方法时，计数器值为空。



#### JVM内存参数设置
另外，JVM的参数很多都是控制这些内存大小的，例如堆的最大最小空间大小，年轻代大小，年轻代最大最小空间等等，还有就是每个线程的堆栈大小